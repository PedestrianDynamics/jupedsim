<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>JPScore: VisiLibity Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">JPScore 0.7.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">VisiLibity Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespace_visi_libity.html" title="VisiLibity&#39;s sole namespace. ">VisiLibity</a>'s sole namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_angle.html">Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">angle in radians represented by a value in the interval [0,2*M_PI]  <a href="class_visi_libity_1_1_angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_visi_libity_1_1_bounding___box.html">Bounding_Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">rectangle with sides parallel to the x- and y-axes  <a href="struct_visi_libity_1_1_bounding___box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">environment represented by simple polygonal outer boundary with simple polygonal holes  <a href="class_visi_libity_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_guards.html">Guards</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">set of <a class="el" href="class_visi_libity_1_1_guards.html" title="set of Guards represented by a list of Points ">Guards</a> represented by a list of Points  <a href="class_visi_libity_1_1_guards.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">line segment in the plane represented by its endpoints  <a href="class_visi_libity_1_1_line___segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> in the plane represented by Cartesian coordinates.  <a href="class_visi_libity_1_1_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> in the plane packaged together with polar coordinates w.r.t. specified origin.  <a href="class_visi_libity_1_1_polar___point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple polygon in the plane represented by list of vertices  <a href="class_visi_libity_1_1_polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">oriented polyline in the plane represented by list of vertices  <a href="class_visi_libity_1_1_polyline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_ray.html">Ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ray in the plane represented by base <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and bearing <a class="el" href="class_visi_libity_1_1_angle.html" title="angle in radians represented by a value in the interval [0,2*M_PI] ">Angle</a>  <a href="class_visi_libity_1_1_ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_visibility___graph.html">Visibility_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">visibility graph of points in an <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a>, represented by adjacency matrix  <a href="class_visi_libity_1_1_visibility___graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_visi_libity_1_1_visibility___polygon.html">Visibility_Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">visibility polygon of a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> in an <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a> or <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>  <a href="class_visi_libity_1_1_visibility___polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae83e7a472af84e482d88ab9963401fcd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ae83e7a472af84e482d88ab9963401fcd">uniform_random_sample</a> (double lower_bound, double upper_bound)</td></tr>
<tr class="memdesc:ae83e7a472af84e482d88ab9963401fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a uniform random sample from an (inclusive) interval on the real line  <a href="#ae83e7a472af84e482d88ab9963401fcd">More...</a><br /></td></tr>
<tr class="separator:ae83e7a472af84e482d88ab9963401fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ddd2a438319145ae0d98553e5631e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a38ddd2a438319145ae0d98553e5631e2">operator==</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a38ddd2a438319145ae0d98553e5631e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff Points' coordinates are identical.  <a href="#a38ddd2a438319145ae0d98553e5631e2">More...</a><br /></td></tr>
<tr class="separator:a38ddd2a438319145ae0d98553e5631e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15188ee9a68b8aef4e039adc13dc31be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15188ee9a68b8aef4e039adc13dc31be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a15188ee9a68b8aef4e039adc13dc31be">operator!=</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a15188ee9a68b8aef4e039adc13dc31be"><td class="mdescLeft">&#160;</td><td class="mdescRight">True iff Points' coordinates are not identical. <br /></td></tr>
<tr class="separator:a15188ee9a68b8aef4e039adc13dc31be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7c17ac562ca46ac0a5cb365209a35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a2d7c17ac562ca46ac0a5cb365209a35e">operator&lt;</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a2d7c17ac562ca46ac0a5cb365209a35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="#a2d7c17ac562ca46ac0a5cb365209a35e">More...</a><br /></td></tr>
<tr class="separator:a2d7c17ac562ca46ac0a5cb365209a35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058b06639d3231e9430b7946c83390c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7058b06639d3231e9430b7946c83390c">operator&gt;</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a7058b06639d3231e9430b7946c83390c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="#a7058b06639d3231e9430b7946c83390c">More...</a><br /></td></tr>
<tr class="separator:a7058b06639d3231e9430b7946c83390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0266fe487ca62b657cca017ba5e3b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aab0266fe487ca62b657cca017ba5e3b2">operator&gt;=</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:aab0266fe487ca62b657cca017ba5e3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="#aab0266fe487ca62b657cca017ba5e3b2">More...</a><br /></td></tr>
<tr class="separator:aab0266fe487ca62b657cca017ba5e3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d3c16417e76f558562c4cea2d7fcb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a48d3c16417e76f558562c4cea2d7fcb5">operator&lt;=</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a48d3c16417e76f558562c4cea2d7fcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare lexicographic order of points  <a href="#a48d3c16417e76f558562c4cea2d7fcb5">More...</a><br /></td></tr>
<tr class="separator:a48d3c16417e76f558562c4cea2d7fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69525459d29f1a3f658c65d08a8c5cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae69525459d29f1a3f658c65d08a8c5cf"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ae69525459d29f1a3f658c65d08a8c5cf">operator+</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:ae69525459d29f1a3f658c65d08a8c5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector addition of Points <br /></td></tr>
<tr class="separator:ae69525459d29f1a3f658c65d08a8c5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b36aa58281fdee246455a2f5065c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a504b36aa58281fdee246455a2f5065c8"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a504b36aa58281fdee246455a2f5065c8">operator-</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a504b36aa58281fdee246455a2f5065c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector subtraction of Points <br /></td></tr>
<tr class="separator:a504b36aa58281fdee246455a2f5065c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ac89fa59679dca49c460fc9f8eacb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ac89fa59679dca49c460fc9f8eacb0"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="separator:aa0ac89fa59679dca49c460fc9f8eacb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d73049e06ea431337f8fb4b6e4a6fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14d73049e06ea431337f8fb4b6e4a6fc"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a14d73049e06ea431337f8fb4b6e4a6fc">operator*</a> (double scalar, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:a14d73049e06ea431337f8fb4b6e4a6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple scaling treats the <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> as a vector <br /></td></tr>
<tr class="separator:a14d73049e06ea431337f8fb4b6e4a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af817ae9a4ab063c3808aa0de8aaa77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9af817ae9a4ab063c3808aa0de8aaa77"></a>
<a class="el" href="class_visi_libity_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a9af817ae9a4ab063c3808aa0de8aaa77">operator*</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, double scalar)</td></tr>
<tr class="memdesc:a9af817ae9a4ab063c3808aa0de8aaa77"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple scaling treats the <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> as a vector <br /></td></tr>
<tr class="separator:a9af817ae9a4ab063c3808aa0de8aaa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa67943ca3ec83270991e0aba4d4000a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aaa67943ca3ec83270991e0aba4d4000a">cross</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:aaa67943ca3ec83270991e0aba4d4000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cross product (signed) magnitude treats the Points as vectors  <a href="#aaa67943ca3ec83270991e0aba4d4000a">More...</a><br /></td></tr>
<tr class="separator:aaa67943ca3ec83270991e0aba4d4000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4ba38875fb632ee9d0237f77f615a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#af8c4ba38875fb632ee9d0237f77f615a">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point1, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point2)</td></tr>
<tr class="memdesc:af8c4ba38875fb632ee9d0237f77f615a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between Points.  <a href="#af8c4ba38875fb632ee9d0237f77f615a">More...</a><br /></td></tr>
<tr class="separator:af8c4ba38875fb632ee9d0237f77f615a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dbebc53067af9f445b0cee233a43e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ad2dbebc53067af9f445b0cee233a43e0">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp)</td></tr>
<tr class="memdesc:ad2dbebc53067af9f445b0cee233a43e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a>.  <a href="#ad2dbebc53067af9f445b0cee233a43e0">More...</a><br /></td></tr>
<tr class="separator:ad2dbebc53067af9f445b0cee233a43e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3dfdcc362e74b9e093710f42ed29b8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a9e3dfdcc362e74b9e093710f42ed29b8">distance</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a9e3dfdcc362e74b9e093710f42ed29b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a>.  <a href="#a9e3dfdcc362e74b9e093710f42ed29b8">More...</a><br /></td></tr>
<tr class="separator:a9e3dfdcc362e74b9e093710f42ed29b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a811b3c6e641a765fa562c1b235b0ef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a2a811b3c6e641a765fa562c1b235b0ef">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray_temp)</td></tr>
<tr class="memdesc:a2a811b3c6e641a765fa562c1b235b0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>.  <a href="#a2a811b3c6e641a765fa562c1b235b0ef">More...</a><br /></td></tr>
<tr class="separator:a2a811b3c6e641a765fa562c1b235b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f24c03b2d19e0db2d590b45deffd2e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a87f24c03b2d19e0db2d590b45deffd2e">distance</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a87f24c03b2d19e0db2d590b45deffd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>.  <a href="#a87f24c03b2d19e0db2d590b45deffd2e">More...</a><br /></td></tr>
<tr class="separator:a87f24c03b2d19e0db2d590b45deffd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5563dc03c315a394d8180444af7ce1b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a5563dc03c315a394d8180444af7ce1b0">distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;polyline_temp)</td></tr>
<tr class="memdesc:a5563dc03c315a394d8180444af7ce1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices ">Polyline</a>.  <a href="#a5563dc03c315a394d8180444af7ce1b0">More...</a><br /></td></tr>
<tr class="separator:a5563dc03c315a394d8180444af7ce1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742bb08e30a47138140a0ff33fa7c9e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a742bb08e30a47138140a0ff33fa7c9e0">distance</a> (const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;polyline_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a742bb08e30a47138140a0ff33fa7c9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices ">Polyline</a>.  <a href="#a742bb08e30a47138140a0ff33fa7c9e0">More...</a><br /></td></tr>
<tr class="separator:a742bb08e30a47138140a0ff33fa7c9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983515dbb1d297fc2b190fa8d8925d5c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a983515dbb1d297fc2b190fa8d8925d5c">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon_temp)</td></tr>
<tr class="memdesc:a983515dbb1d297fc2b190fa8d8925d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>'s boundary.  <a href="#a983515dbb1d297fc2b190fa8d8925d5c">More...</a><br /></td></tr>
<tr class="separator:a983515dbb1d297fc2b190fa8d8925d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a101b4f71120c5e30a1b50b2ce5b3e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a9a101b4f71120c5e30a1b50b2ce5b3e9">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a9a101b4f71120c5e30a1b50b2ce5b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>'s boundary.  <a href="#a9a101b4f71120c5e30a1b50b2ce5b3e9">More...</a><br /></td></tr>
<tr class="separator:a9a101b4f71120c5e30a1b50b2ce5b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49beee9427a282c7fa9b26248bb8feb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac49beee9427a282c7fa9b26248bb8feb">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp, const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;environment_temp)</td></tr>
<tr class="memdesc:ac49beee9427a282c7fa9b26248bb8feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a>'s boundary.  <a href="#ac49beee9427a282c7fa9b26248bb8feb">More...</a><br /></td></tr>
<tr class="separator:ac49beee9427a282c7fa9b26248bb8feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9731b17ed285d5b937aa49f0e676a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a1a9731b17ed285d5b937aa49f0e676a3">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;environment_temp, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:a1a9731b17ed285d5b937aa49f0e676a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a>'s boundary.  <a href="#a1a9731b17ed285d5b937aa49f0e676a3">More...</a><br /></td></tr>
<tr class="separator:a1a9731b17ed285d5b937aa49f0e676a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe9be2353f10d88512c5bd70ccdb95b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefe9be2353f10d88512c5bd70ccdb95b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aefe9be2353f10d88512c5bd70ccdb95b">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;point_temp)</td></tr>
<tr class="memdesc:aefe9be2353f10d88512c5bd70ccdb95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> <br /></td></tr>
<tr class="separator:aefe9be2353f10d88512c5bd70ccdb95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c052b8939fccc3f35b75950885656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a291c052b8939fccc3f35b75950885656">operator==</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2)</td></tr>
<tr class="memdesc:a291c052b8939fccc3f35b75950885656"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff endpoint coordinates are exactly equal, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> has size 0  <a href="#a291c052b8939fccc3f35b75950885656">More...</a><br /></td></tr>
<tr class="separator:a291c052b8939fccc3f35b75950885656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee21c531f73f2fe7f1ec709c6b624b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee21c531f73f2fe7f1ec709c6b624b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a6ee21c531f73f2fe7f1ec709c6b624b4">operator!=</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2)</td></tr>
<tr class="memdesc:a6ee21c531f73f2fe7f1ec709c6b624b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff endpoint coordinates are not == <br /></td></tr>
<tr class="separator:a6ee21c531f73f2fe7f1ec709c6b624b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63fae6bd727b4fb438bd0808b9b9eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ab63fae6bd727b4fb438bd0808b9b9eb2">equivalent</a> (<a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> line_segment1, <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> line_segment2, double epsilon=0)</td></tr>
<tr class="memdesc:ab63fae6bd727b4fb438bd0808b9b9eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff line segments' endpoints match up w/in a (closed) <em>epsilon</em> ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> has size 0  <a href="#ab63fae6bd727b4fb438bd0808b9b9eb2">More...</a><br /></td></tr>
<tr class="separator:ab63fae6bd727b4fb438bd0808b9b9eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b882c36565453f1f3627b530cf40c4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a80b882c36565453f1f3627b530cf40c4">distance</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2)</td></tr>
<tr class="memdesc:a80b882c36565453f1f3627b530cf40c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between Line_Segments.  <a href="#a80b882c36565453f1f3627b530cf40c4">More...</a><br /></td></tr>
<tr class="separator:a80b882c36565453f1f3627b530cf40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dae697df9347a8328d86926d294ed02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a1dae697df9347a8328d86926d294ed02">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon)</td></tr>
<tr class="memdesc:a1dae697df9347a8328d86926d294ed02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>.  <a href="#a1dae697df9347a8328d86926d294ed02">More...</a><br /></td></tr>
<tr class="separator:a1dae697df9347a8328d86926d294ed02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccb6ad5efaaf65da0adefc86111fb5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7ccb6ad5efaaf65da0adefc86111fb5b">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment)</td></tr>
<tr class="memdesc:a7ccb6ad5efaaf65da0adefc86111fb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>.  <a href="#a7ccb6ad5efaaf65da0adefc86111fb5b">More...</a><br /></td></tr>
<tr class="separator:a7ccb6ad5efaaf65da0adefc86111fb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa0ac73a3d3250473614f4332c3f772"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#acfa0ac73a3d3250473614f4332c3f772">intersect</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2, double epsilon=0.0)</td></tr>
<tr class="memdesc:acfa0ac73a3d3250473614f4332c3f772"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff the Euclidean distance between Line_Segments is no greater than <em>epsilon</em>, false if either line segment has size 0  <a href="#acfa0ac73a3d3250473614f4332c3f772">More...</a><br /></td></tr>
<tr class="separator:acfa0ac73a3d3250473614f4332c3f772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8551551fe3ae479755b02342b3f3cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a4b8551551fe3ae479755b02342b3f3cd">intersect_proper</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2, double epsilon=0.0)</td></tr>
<tr class="memdesc:a4b8551551fe3ae479755b02342b3f3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff line segments intersect properly w/in epsilon, false if either line segment has size 0  <a href="#a4b8551551fe3ae479755b02342b3f3cd">More...</a><br /></td></tr>
<tr class="separator:a4b8551551fe3ae479755b02342b3f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab815eaf17c3790348f229b63b2130b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#acab815eaf17c3790348f229b63b2130b">intersection</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment1, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment2, double epsilon=0.0)</td></tr>
<tr class="memdesc:acab815eaf17c3790348f229b63b2130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">intersection of Line_Segments  <a href="#acab815eaf17c3790348f229b63b2130b">More...</a><br /></td></tr>
<tr class="separator:acab815eaf17c3790348f229b63b2130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e06c0dc7b2751c2e8dabfeb155745"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73e06c0dc7b2751c2e8dabfeb155745"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aa73e06c0dc7b2751c2e8dabfeb155745">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp)</td></tr>
<tr class="memdesc:aa73e06c0dc7b2751c2e8dabfeb155745"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> <br /></td></tr>
<tr class="separator:aa73e06c0dc7b2751c2e8dabfeb155745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1cb3a74ef6cea43ac9f9e2cc5af97a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e1cb3a74ef6cea43ac9f9e2cc5af97a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a5e1cb3a74ef6cea43ac9f9e2cc5af97a">operator==</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a5e1cb3a74ef6cea43ac9f9e2cc5af97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a5e1cb3a74ef6cea43ac9f9e2cc5af97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91da0d86f4bc8d5c858128261344f42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab91da0d86f4bc8d5c858128261344f42"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ab91da0d86f4bc8d5c858128261344f42">operator!=</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ab91da0d86f4bc8d5c858128261344f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:ab91da0d86f4bc8d5c858128261344f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5461d875fd043baf6ed0c06a2e8f45d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5461d875fd043baf6ed0c06a2e8f45d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac5461d875fd043baf6ed0c06a2e8f45d">operator&gt;</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ac5461d875fd043baf6ed0c06a2e8f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:ac5461d875fd043baf6ed0c06a2e8f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5460b410d9a16cdc1bf2e1bc396a1f13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5460b410d9a16cdc1bf2e1bc396a1f13"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a5460b410d9a16cdc1bf2e1bc396a1f13">operator&lt;</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a5460b410d9a16cdc1bf2e1bc396a1f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a5460b410d9a16cdc1bf2e1bc396a1f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8407f54ddae6381c47064a2230b6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b8407f54ddae6381c47064a2230b6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a88b8407f54ddae6381c47064a2230b6c">operator&gt;=</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a88b8407f54ddae6381c47064a2230b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a88b8407f54ddae6381c47064a2230b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f81e7fd8afa84cbc9e7f59b35f5af6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f81e7fd8afa84cbc9e7f59b35f5af6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a58f81e7fd8afa84cbc9e7f59b35f5af6">operator&lt;=</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a58f81e7fd8afa84cbc9e7f59b35f5af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare angle radians <br /></td></tr>
<tr class="separator:a58f81e7fd8afa84cbc9e7f59b35f5af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88995c5a50c9b6c94c50f1c37a384f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae88995c5a50c9b6c94c50f1c37a384f5"></a>
<a class="el" href="class_visi_libity_1_1_angle.html">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ae88995c5a50c9b6c94c50f1c37a384f5">operator+</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ae88995c5a50c9b6c94c50f1c37a384f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add angles' radians and mod into [0, 2*M_PI) <br /></td></tr>
<tr class="separator:ae88995c5a50c9b6c94c50f1c37a384f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bde1742747b574d5619553d63beb69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00bde1742747b574d5619553d63beb69"></a>
<a class="el" href="class_visi_libity_1_1_angle.html">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a00bde1742747b574d5619553d63beb69">operator-</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a00bde1742747b574d5619553d63beb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract angles' radians and mod into [0, 2*M_PI) <br /></td></tr>
<tr class="separator:a00bde1742747b574d5619553d63beb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54c3c29b782a7bcaaf80df7c870bbfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ab54c3c29b782a7bcaaf80df7c870bbfb">geodesic_distance</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:ab54c3c29b782a7bcaaf80df7c870bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">geodesic distance in radians between Angles  <a href="#ab54c3c29b782a7bcaaf80df7c870bbfb">More...</a><br /></td></tr>
<tr class="separator:ab54c3c29b782a7bcaaf80df7c870bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d98628c28fc4ae2e2ca9a47b341c673"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a6d98628c28fc4ae2e2ca9a47b341c673">geodesic_direction</a> (const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle1, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle2)</td></tr>
<tr class="memdesc:a6d98628c28fc4ae2e2ca9a47b341c673"><td class="mdescLeft">&#160;</td><td class="mdescRight">1.0 =&gt; geodesic path from angle1 to angle2 is couterclockwise, -1.0 =&gt; clockwise  <a href="#a6d98628c28fc4ae2e2ca9a47b341c673">More...</a><br /></td></tr>
<tr class="separator:a6d98628c28fc4ae2e2ca9a47b341c673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24b75a9754489bae1b26b543e3264d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad24b75a9754489bae1b26b543e3264d5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ad24b75a9754489bae1b26b543e3264d5">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;angle_temp)</td></tr>
<tr class="memdesc:ad24b75a9754489bae1b26b543e3264d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_angle.html" title="angle in radians represented by a value in the interval [0,2*M_PI] ">Angle</a> <br /></td></tr>
<tr class="separator:ad24b75a9754489bae1b26b543e3264d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149518e70a1a5fcde96173d7d3fb9f9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a149518e70a1a5fcde96173d7d3fb9f9f">operator==</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:a149518e70a1a5fcde96173d7d3fb9f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare member data  <a href="#a149518e70a1a5fcde96173d7d3fb9f9f">More...</a><br /></td></tr>
<tr class="separator:a149518e70a1a5fcde96173d7d3fb9f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cdaff47e746e8f577ef051ffe1c63a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1cdaff47e746e8f577ef051ffe1c63a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="separator:af1cdaff47e746e8f577ef051ffe1c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac507aa8babe8577aa58a90fff0f3a1ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac507aa8babe8577aa58a90fff0f3a1ed">operator&gt;</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:ac507aa8babe8577aa58a90fff0f3a1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="#ac507aa8babe8577aa58a90fff0f3a1ed">More...</a><br /></td></tr>
<tr class="separator:ac507aa8babe8577aa58a90fff0f3a1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9d951f84a0a01186899f00ce2eb24f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7b9d951f84a0a01186899f00ce2eb24f">operator&lt;</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:a7b9d951f84a0a01186899f00ce2eb24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="#a7b9d951f84a0a01186899f00ce2eb24f">More...</a><br /></td></tr>
<tr class="separator:a7b9d951f84a0a01186899f00ce2eb24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87a4a15e00ffdfe72fbb2b56d4020a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac87a4a15e00ffdfe72fbb2b56d4020a3">operator&gt;=</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:ac87a4a15e00ffdfe72fbb2b56d4020a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="#ac87a4a15e00ffdfe72fbb2b56d4020a3">More...</a><br /></td></tr>
<tr class="separator:ac87a4a15e00ffdfe72fbb2b56d4020a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083b69c4720e5cd817d7703c6e74faf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a083b69c4720e5cd817d7703c6e74faf2">operator&lt;=</a> (const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point1, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point2)</td></tr>
<tr class="memdesc:a083b69c4720e5cd817d7703c6e74faf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare according to polar lexicographic order (smaller bearing, then smaller range)  <a href="#a083b69c4720e5cd817d7703c6e74faf2">More...</a><br /></td></tr>
<tr class="separator:a083b69c4720e5cd817d7703c6e74faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed442d343a0cff676f732943ef189ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ed442d343a0cff676f732943ef189ab"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a8ed442d343a0cff676f732943ef189ab">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;polar_point_temp)</td></tr>
<tr class="memdesc:a8ed442d343a0cff676f732943ef189ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_polar___point.html" title="Point in the plane packaged together with polar coordinates w.r.t. specified origin. ">Polar_Point</a> <br /></td></tr>
<tr class="separator:a8ed442d343a0cff676f732943ef189ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ecb7431af376e585b58df6f10235a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#aa5ecb7431af376e585b58df6f10235a7">operator==</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray1, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray2)</td></tr>
<tr class="memdesc:aa5ecb7431af376e585b58df6f10235a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare member data  <a href="#aa5ecb7431af376e585b58df6f10235a7">More...</a><br /></td></tr>
<tr class="separator:aa5ecb7431af376e585b58df6f10235a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c9ca72e0e00a3343959b089c8a0442"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ad1c9ca72e0e00a3343959b089c8a0442">operator!=</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray1, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray2)</td></tr>
<tr class="memdesc:ad1c9ca72e0e00a3343959b089c8a0442"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare member data  <a href="#ad1c9ca72e0e00a3343959b089c8a0442">More...</a><br /></td></tr>
<tr class="separator:ad1c9ca72e0e00a3343959b089c8a0442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc9dcdaa19f0eb9b9e1eca41b88bdb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#abdc9dcdaa19f0eb9b9e1eca41b88bdb0">intersection</a> (const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> ray_temp, const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp, double epsilon=0.0)</td></tr>
<tr class="memdesc:abdc9dcdaa19f0eb9b9e1eca41b88bdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>  <a href="#abdc9dcdaa19f0eb9b9e1eca41b88bdb0">More...</a><br /></td></tr>
<tr class="separator:abdc9dcdaa19f0eb9b9e1eca41b88bdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5acd48758cf845aa95e8520b7ad923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a5b5acd48758cf845aa95e8520b7ad923">intersection</a> (const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;line_segment_temp, const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;ray_temp, double epsilon=0.0)</td></tr>
<tr class="memdesc:a5b5acd48758cf845aa95e8520b7ad923"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>  <a href="#a5b5acd48758cf845aa95e8520b7ad923">More...</a><br /></td></tr>
<tr class="separator:a5b5acd48758cf845aa95e8520b7ad923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ec75acc21d42014d5dd7a7c11c93d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94ec75acc21d42014d5dd7a7c11c93d3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;polyline_temp)</td></tr>
<tr class="separator:a94ec75acc21d42014d5dd7a7c11c93d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96076229fbc5ad8d484428bee92b153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ac96076229fbc5ad8d484428bee92b153">operator==</a> (<a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon1, <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon2)</td></tr>
<tr class="memdesc:ac96076229fbc5ad8d484428bee92b153"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff vertex lists are identical, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> has size 0  <a href="#ac96076229fbc5ad8d484428bee92b153">More...</a><br /></td></tr>
<tr class="separator:ac96076229fbc5ad8d484428bee92b153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88b241ecd276c15af5cd8b9edd7a6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f88b241ecd276c15af5cd8b9edd7a6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon1, <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon2)</td></tr>
<tr class="separator:a9f88b241ecd276c15af5cd8b9edd7a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea3cfda0e212765b7b3bc69d46f7b2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a8ea3cfda0e212765b7b3bc69d46f7b2f">equivalent</a> (<a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon1, <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> polygon2, double epsilon=0.0)</td></tr>
<tr class="memdesc:a8ea3cfda0e212765b7b3bc69d46f7b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">true iff the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>'s vertices match up w/in a (closed) epsilon ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> has size 0  <a href="#a8ea3cfda0e212765b7b3bc69d46f7b2f">More...</a><br /></td></tr>
<tr class="separator:a8ea3cfda0e212765b7b3bc69d46f7b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dca7869e72683bc8a661a5e7553474"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a38dca7869e72683bc8a661a5e7553474">boundary_distance</a> (const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon1, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon2)</td></tr>
<tr class="memdesc:a38dca7869e72683bc8a661a5e7553474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between Polygons' boundaries.  <a href="#a38dca7869e72683bc8a661a5e7553474">More...</a><br /></td></tr>
<tr class="separator:a38dca7869e72683bc8a661a5e7553474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913bacb6d219145c8d458e67f1de91e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af913bacb6d219145c8d458e67f1de91e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;polygon_temp)</td></tr>
<tr class="separator:af913bacb6d219145c8d458e67f1de91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9389a3b97d3d5b7aa6819690a100167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9389a3b97d3d5b7aa6819690a100167"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#ae9389a3b97d3d5b7aa6819690a100167">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;environment_temp)</td></tr>
<tr class="memdesc:ae9389a3b97d3d5b7aa6819690a100167"><td class="mdescLeft">&#160;</td><td class="mdescRight">printing <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a> <br /></td></tr>
<tr class="separator:ae9389a3b97d3d5b7aa6819690a100167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af106424bac592e29491becd761fdac53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af106424bac592e29491becd761fdac53"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#af106424bac592e29491becd761fdac53">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_guards.html">Guards</a> &amp;guards)</td></tr>
<tr class="memdesc:af106424bac592e29491becd761fdac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_guards.html" title="set of Guards represented by a list of Points ">Guards</a> <br /></td></tr>
<tr class="separator:af106424bac592e29491becd761fdac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0683806072e873c2156cb43686ea5b3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0683806072e873c2156cb43686ea5b3e"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a0683806072e873c2156cb43686ea5b3e">operator&lt;&lt;</a> (std::ostream &amp;outs, const <a class="el" href="class_visi_libity_1_1_visibility___graph.html">Visibility_Graph</a> &amp;visibility_graph)</td></tr>
<tr class="memdesc:a0683806072e873c2156cb43686ea5b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">print <a class="el" href="class_visi_libity_1_1_visibility___graph.html" title="visibility graph of points in an Environment, represented by adjacency matrix ">Visibility_Graph</a> adjacency matrix <br /></td></tr>
<tr class="separator:a0683806072e873c2156cb43686ea5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ac10ccfdc14c4c8093b7528c1fd7fd5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_visi_libity.html#a7ac10ccfdc14c4c8093b7528c1fd7fd5">FIOS_PRECISION</a> = 10</td></tr>
<tr class="memdesc:a7ac10ccfdc14c4c8093b7528c1fd7fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">floating-point display precision.  <a href="#a7ac10ccfdc14c4c8093b7528c1fd7fd5">More...</a><br /></td></tr>
<tr class="separator:a7ac10ccfdc14c4c8093b7528c1fd7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespace_visi_libity.html" title="VisiLibity&#39;s sole namespace. ">VisiLibity</a>'s sole namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a983515dbb1d297fc2b190fa8d8925d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a9a101b4f71120c5e30a1b50b2ce5b3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="ac49beee9427a282c7fa9b26248bb8feb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>environment_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a1a9731b17ed285d5b937aa49f0e676a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>environment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a>'s boundary. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_environment.html" title="environment represented by simple polygonal outer boundary with simple polygonal holes ...">Environment</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a1dae697df9347a8328d86926d294ed02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>line_segment.size()</em> &gt; 0 and <em>polygon.n()</em> &gt; 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a7ccb6ad5efaaf65da0adefc86111fb5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> and the boundary of a <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>line_segment.size()</em> &gt; 0 and <em>polygon.n()</em> &gt; 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a38dca7869e72683bc8a661a5e7553474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::boundary_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>polygon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between Polygons' boundaries. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>polygon1</em> and <em>polygon2</em> each have greater than 0 vertices </dd></dl>

</div>
</div>
<a class="anchor" id="aaa67943ca3ec83270991e0aba4d4000a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cross product (signed) magnitude treats the Points as vectors </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Points' data are numbers </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is equal to the (signed) area of the parallelogram created by the Points viewed as vectors. </dd></dl>

</div>
</div>
<a class="anchor" id="af8c4ba38875fb632ee9d0237f77f615a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between Points. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Points' data are numbers </dd></dl>

</div>
</div>
<a class="anchor" id="ad2dbebc53067af9f445b0cee233a43e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a9e3dfdcc362e74b9e093710f42ed29b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a2a811b3c6e641a765fa562c1b235b0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s and <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>'s data are numbers </dd></dl>

</div>
</div>
<a class="anchor" id="a87f24c03b2d19e0db2d590b45deffd2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s and <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>'s data are numbers </dd></dl>

</div>
</div>
<a class="anchor" id="a5563dc03c315a394d8180444af7ce1b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices ">Polyline</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices ">Polyline</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a742bb08e30a47138140a0ff33fa7c9e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polyline.html">Polyline</a> &amp;&#160;</td>
          <td class="paramname"><em>polyline_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point_temp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between a <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> and a <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices ">Polyline</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a>'s data are numbers and the <a class="el" href="class_visi_libity_1_1_polyline.html" title="oriented polyline in the plane represented by list of vertices ">Polyline</a> is nonempty </dd></dl>

</div>
</div>
<a class="anchor" id="a80b882c36565453f1f3627b530cf40c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Euclidean distance between Line_Segments. </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>line_segment1.size()</em> &gt; 0 and <em>line_segment2.size()</em> &gt; 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab63fae6bd727b4fb438bd0808b9b9eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a>&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff line segments' endpoints match up w/in a (closed) <em>epsilon</em> ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> has size 0 </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>this function will return true even if it has to flip the orientation of one of the segments to get the vertices to match up </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea3cfda0e212765b7b3bc69d46f7b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff the <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a>'s vertices match up w/in a (closed) epsilon ball of each other, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> has size 0 </p>
<p>Respects number, ordering, and orientation of vertices, i.e., even if the (conceptual) polygons represented by two Polygons are identical, they are not considered <em>epsilon</em> - equivalent unless the number of vertices is the same, the orientations are the same (cw vs. ccw list), and the Points of the vertex lists match up within epsilon. This function does attempt to match the polygons for all possible cyclic permutations, hence the quadratic time complexity. </p><dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>O(n^2) time complexity, where n is the number of vertices representing the polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a6d98628c28fc4ae2e2ca9a47b341c673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::geodesic_direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1.0 =&gt; geodesic path from angle1 to angle2 is couterclockwise, -1.0 =&gt; clockwise </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>angle1</em> and <em>angle2</em> data are numbers </dd></dl>

</div>
</div>
<a class="anchor" id="ab54c3c29b782a7bcaaf80df7c870bbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::geodesic_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_angle.html">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>angle2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>geodesic distance in radians between Angles </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>angle1</em> and <em>angle2</em> data are numbers </dd></dl>

</div>
</div>
<a class="anchor" id="acfa0ac73a3d3250473614f4332c3f772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff the Euclidean distance between Line_Segments is no greater than <em>epsilon</em>, false if either line segment has size 0 </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>

</div>
</div>
<a class="anchor" id="a4b8551551fe3ae479755b02342b3f3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::intersect_proper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff line segments intersect properly w/in epsilon, false if either line segment has size 0 </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true iff Line_Segments intersect exactly at a single point in their relative interiors. For robustness, here the relative interior of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> is consider to be any <a class="el" href="class_visi_libity_1_1_point.html" title="Point in the plane represented by Cartesian coordinates. ">Point</a> in the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> which is a distance greater than <em>epsilon</em> from both endpoints. </dd></dl>

</div>
</div>
<a class="anchor" id="acab815eaf17c3790348f229b63b2130b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> VisiLibity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>intersection of Line_Segments </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> of size 0, 1, or 2 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>size 0 results if the distance (or at least the floating-point computed distance) between line_segment1 and line_segment2 is (strictly) greater than epsilon. size 1 results if the segments intersect poperly, form a T intersection, or &ndash; intersection. size 2 results when two or more endpoints are a Euclidean distance no greater than <em>epsilon</em> from the opposite segment, and the overlap of the segments has a length greater than <em>epsilon</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="abdc9dcdaa19f0eb9b9e1eca41b88bdb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> VisiLibity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a>&#160;</td>
          <td class="paramname"><em>ray_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a> </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>member data of <em>ray_temp</em> has been assigned (numbers) and <em>line_segment_temp</em> has size greater than 0 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>as a convention, if the intersection has positive length, the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> returned has the first point closest to the <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>'s base point </dd></dl>

</div>
</div>
<a class="anchor" id="a5b5acd48758cf845aa95e8520b7ad923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> VisiLibity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray_temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the intersection of a <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> with a <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a> </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>member data of <em>ray_temp</em> has been assigned (numbers) and <em>line_segment_temp</em> has size greater than 0 </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>as a convention, if the intersection has positive length, the <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> returned has the first point closest to the <a class="el" href="class_visi_libity_1_1_ray.html" title="ray in the plane represented by base Point and bearing Angle ">Ray</a>'s base point </dd></dl>

</div>
</div>
<a class="anchor" id="ad1c9ca72e0e00a3343959b089c8a0442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare member data </p>
<dl class="section remark"><dt>Remarks</dt><dd>negation of == </dd></dl>

</div>
</div>
<a class="anchor" id="a2d7c17ac562ca46ac0a5cb365209a35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p>For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a class="anchor" id="a7b9d951f84a0a01186899f00ce2eb24f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p>false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a class="anchor" id="a48d3c16417e76f558562c4cea2d7fcb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p>For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a class="anchor" id="a083b69c4720e5cd817d7703c6e74faf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p>false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a class="anchor" id="a38ddd2a438319145ae0d98553e5631e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True iff Points' coordinates are identical. </p>
<dl class="section remark"><dt>Remarks</dt><dd>NAN==NAN returns false, so if either point has not been assigned real number coordinates, they will not be == </dd></dl>

</div>
</div>
<a class="anchor" id="a291c052b8939fccc3f35b75950885656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_line___segment.html">Line_Segment</a> &amp;&#160;</td>
          <td class="paramname"><em>line_segment2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff endpoint coordinates are exactly equal, but false if either <a class="el" href="class_visi_libity_1_1_line___segment.html" title="line segment in the plane represented by its endpoints ">Line_Segment</a> has size 0 </p>
<dl class="section remark"><dt>Remarks</dt><dd>respects ordering of vertices, i.e., even if the line segments overlap exactly, they are not considered == unless the orientations are the same </dd></dl>

</div>
</div>
<a class="anchor" id="a149518e70a1a5fcde96173d7d3fb9f9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare member data </p>
<dl class="section remark"><dt>Remarks</dt><dd>returns false if any member data are NaN </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ecb7431af376e585b58df6f10235a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>ray2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare member data </p>
<dl class="section remark"><dt>Remarks</dt><dd>returns false if any member data are NaN </dd></dl>

</div>
</div>
<a class="anchor" id="ac96076229fbc5ad8d484428bee92b153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_visi_libity_1_1_polygon.html">Polygon</a>&#160;</td>
          <td class="paramname"><em>polygon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>true iff vertex lists are identical, but false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> has size 0 </p>
<dl class="section remark"><dt>Remarks</dt><dd>returns false if either <a class="el" href="class_visi_libity_1_1_polygon.html" title="simple polygon in the plane represented by list of vertices ">Polygon</a> has size 0 </dd>
<dd>
O(n) time complexity </dd></dl>

</div>
</div>
<a class="anchor" id="a7058b06639d3231e9430b7946c83390c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p>For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a class="anchor" id="ac507aa8babe8577aa58a90fff0f3a1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p>false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a class="anchor" id="aab0266fe487ca62b657cca017ba5e3b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare lexicographic order of points </p>
<p>For Points p1 and p2, p1 &lt; p2 iff either p1.x() &lt; p2.x() or p1.x()==p2.x() and p1.y()&lt;p2.y(). False if any member data have not been assigned (numbers). </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a line parallel to one of the axes </dd></dl>

</div>
</div>
<a class="anchor" id="ac87a4a15e00ffdfe72fbb2b56d4020a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VisiLibity::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_visi_libity_1_1_polar___point.html">Polar_Point</a> &amp;&#160;</td>
          <td class="paramname"><em>polar_point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare according to polar lexicographic order (smaller bearing, then smaller range) </p>
<p>false if any member data have not been assigned (numbers) </p><dl class="section remark"><dt>Remarks</dt><dd>lex. comparison is very sensitive to perturbations if two Points nearly define a radial line </dd></dl>

</div>
</div>
<a class="anchor" id="ae83e7a472af84e482d88ab9963401fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VisiLibity::uniform_random_sample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a uniform random sample from an (inclusive) interval on the real line </p>
<dl class="section author"><dt>Author</dt><dd>Karl J. Obermeyer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>lower bound of the real interval </td></tr>
    <tr><td class="paramname">upper_bound</td><td>upper bound of the real interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>lower_bound</em> &lt;= <em>upper_bound</em> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a random sample from a uniform probability distribution on the real interval [<em>lower_bound</em>, <em>upper_bound</em>] </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Uses the Standard Library's rand() function. rand() should be seeded (only necessary once at the beginning of the program) using the command std::srand( std::time( NULL ) ); rand(); </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>performance degrades as upper_bound - lower_bound approaches RAND_MAX. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a7ac10ccfdc14c4c8093b7528c1fd7fd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int VisiLibity::FIOS_PRECISION = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>floating-point display precision. </p>
<p>This is the default precision with which floating point numbers are displayed or written to files for classes with a write_to_file() method. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 6 2016 15:45:10 for JPScore by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
